P2 project: 
- Interpreter for “Simplified Python Language”
- P2.0 BNF Grammar
- P2.1 Lexer
- P2.2 Parser
- P2.3 Interpreter
- P2.4* Add support of control structures: (“if”, “while”)
- No whitespace/tabulation effect
- No method invocations (‘print’ as a keyword)
- No class/function definitions
- No imports/multi files


x=5;
if (x>3) {
    y = x+2;
}
else {    
    y = x * (2+3);
}
end;
print y;


You should produce the following lexemes:
[ "x", "=", "5", ";", "if", "(", "x", ">", "3", ")", "{", "y", "=", "x", "+", "2", ";", "}",
"else", "{", "y", "=", "x", "*", "(", "2", "+", "3", ")", ";", "}", "print", "y", ";" ]


P2.0 BNF Grammar: 
<program> ::= <statement> | <program> <separator> 
<separator> ::= "\n" | ";"
<statement> ::= <expr> | <if_statement> | <function_call>
<function_call> ::= "print" <identified>
<if_statement> ::= "if" <condition> "{" <program> "}" "else" <else_statement>?
<else_statement> ::= "else" <program> 
<condition> ::= <expr> <comparison> <expr>
<comparison> ::= "==" |  "<=" |  ">=" |  "<" |  ">" |  "!=" 
<expr> ::= <term> | <expr> "+" <term> | <expr> "-" <term>
<term> ::= <factor> | <term> * <factor> | <term> / <factor>
<factor> ::= <number> | <identifier> | "(" <expr> ")"
<identifier> ::= <letter> | <identifier> <letter_or_digit> 
<number> ::= <digit> | <number> <digit> 
<letter_or_digit> ::= <letter> | <digit> 
<digit> ::= "0" | "1" | "2" | "3" | "4"| "5" | "6" | "7"| "8" | "9"
<letter> ::= "a" | "b" | "c" | ... | "z" | "A" | "B" | ... | "Z"

P2.1 Lexer: 